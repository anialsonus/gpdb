-- start_ignore
create table scale_factor_repl(c1 int, c2 int) distributed replicated;
create table scale_factor_distr(c1 int, c2 int) distributed by (c1);
create table scale_factor_rand_distr(c1 int, c2 int);
create table scale_factor_partitioned (a int) partition by range(a) (start(1) end(10) every(1));
create table scale_factor_master_only (a int);

set allow_system_table_mods=true;
delete from gp_distribution_policy where localoid='scale_factor_master_only'::regclass;
reset allow_system_table_mods;

set allow_system_table_mods = on;
create table scale_factor_part_distr(c1 int, c2 int) distributed by(c1);
update gp_distribution_policy set numsegments = 2 where localoid = 'scale_factor_part_distr'::regclass;
reset allow_system_table_mods;

insert into scale_factor_repl select i,i from generate_series(1, 10)i;
insert into scale_factor_distr select i,i from generate_series(1, 10)i;
insert into scale_factor_rand_distr select i,i from generate_series(5, 15)i;
insert into scale_factor_part_distr select i,i from generate_series(1, 10)i;
insert into scale_factor_partitioned values (1), (1), (1);
insert into scale_factor_master_only select generate_series(1, 10);

analyze scale_factor_repl;
analyze scale_factor_distr;
analyze scale_factor_rand_distr;
analyze scale_factor_part_distr;
analyze scale_factor_partitioned;
analyze scale_factor_master_only;
-- end_ignore
-- This plan from postgres optimizer may seem incorrect at the first glance, but in fact
-- Gather Motion has fractional number of rows, which is 3.3... and this number was rounded up
-- to 4. Also, Hash Semi Join below this motion has the same rows number, but scaled by
-- segments number, which is 3 in our case. That is, we get 1.1 rows and round them to 2.
explain select * from scale_factor_distr where c2 in (select c1/2 from scale_factor_rand_distr limit 3);
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice3; segments: 3)  (cost=1.18..4.35 rows=4 width=8)
   ->  Hash Semi Join  (cost=1.18..4.35 rows=2 width=8)
         Hash Cond: (scale_factor_distr.c2 = ((scale_factor_rand_distr.c1 / 2)))
         ->  Seq Scan on scale_factor_distr  (cost=0.00..3.10 rows=4 width=8)
         ->  Hash  (cost=1.07..1.07 rows=3 width=4)
               ->  Broadcast Motion 1:3  (slice2; segments: 1)  (cost=0.00..1.07 rows=3 width=4)
                     ->  Limit  (cost=0.00..0.92 rows=3 width=4)
                           ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..0.92 rows=3 width=4)
                                 ->  Limit  (cost=0.00..0.86 rows=1 width=4)
                                       ->  Seq Scan on scale_factor_rand_distr  (cost=0.00..3.14 rows=4 width=4)
 Optimizer: Postgres query optimizer
(11 rows)

explain select * from scale_factor_repl limit 1;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Limit  (cost=0.00..0.13 rows=1 width=8)
   ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=0.00..1.30 rows=10 width=8)
         ->  Seq Scan on scale_factor_repl  (cost=0.00..1.10 rows=10 width=8)
 Optimizer: Postgres query optimizer
(4 rows)

explain select * from scale_factor_distr where c1 = 2 or c1 = 5 or c1 = 9;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..3.17 rows=3 width=8)
   ->  Seq Scan on scale_factor_distr  (cost=0.00..3.17 rows=2 width=8)
         Filter: ((c1 = 2) OR (c1 = 5) OR (c1 = 9))
 Optimizer: Postgres query optimizer
(4 rows)

explain select count(*) from scale_factor_partitioned where a = 1;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=1304.05..1304.06 rows=1 width=8)
   ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=1303.99..1304.04 rows=1 width=8)
         ->  Aggregate  (cost=1303.99..1304.00 rows=1 width=8)
               ->  Append  (cost=0.00..1303.75 rows=97 width=0)
                     ->  Seq Scan on scale_factor_partitioned_1_prt_1  (cost=0.00..1303.75 rows=97 width=0)
                           Filter: (a = 1)
 Optimizer: Postgres query optimizer
(7 rows)

explain select * from scale_factor_part_distr;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2.10 rows=10 width=8)
   ->  Seq Scan on scale_factor_part_distr  (cost=0.00..2.10 rows=5 width=8)
 Optimizer: Postgres query optimizer
(3 rows)

select * from get_motion_snd_recv($$
  update scale_factor_repl a set c1 = b.c2 from scale_factor_part_distr b returning *;
$$);
       node_name        | motion_snd | motion_recv 
------------------------+------------+-------------
 Explicit Gather Motion | 3          | 1
 Broadcast Motion       | 2          | 3
(2 rows)

explain update scale_factor_repl a set c1 = b.c2 from scale_factor_part_distr b returning *;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Explicit Gather Motion 3:1  (slice2; segments: 3)  (cost=10000000000.00..10000000006.98 rows=100 width=28)
   ->  Update on scale_factor_repl a  (cost=10000000000.00..10000000006.98 rows=100 width=28)
         ->  Nested Loop  (cost=10000000000.00..10000000006.98 rows=100 width=28)
               ->  Seq Scan on scale_factor_repl a  (cost=0.00..1.10 rows=10 width=14)
               ->  Materialize  (cost=0.00..2.65 rows=10 width=14)
                     ->  Broadcast Motion 2:3  (slice1; segments: 2)  (cost=0.00..2.50 rows=10 width=14)
                           ->  Seq Scan on scale_factor_part_distr b  (cost=0.00..2.10 rows=5 width=14)
 Optimizer: Postgres query optimizer
(8 rows)

select * from get_motion_snd_recv ($$
  delete from scale_factor_part_distr a using scale_factor_rand_distr b where b.c1=a.c2;
$$);
          node_name           | motion_snd | motion_recv 
------------------------------+------------+-------------
 Explicit Redistribute Motion | 3          | 2
 Redistribute Motion          | 2          | 3
(2 rows)

explain delete from scale_factor_part_distr a using scale_factor_rand_distr b where b.c1=a.c2;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Delete on scale_factor_part_distr a  (cost=2.43..5.68 rows=5 width=16)
   ->  Explicit Redistribute Motion 3:2  (slice2; segments: 3)  (cost=2.43..5.68 rows=4 width=16)
         ->  Hash Join  (cost=2.43..5.68 rows=4 width=16)
               Hash Cond: (b.c1 = a.c2)
               ->  Seq Scan on scale_factor_rand_distr b  (cost=0.00..3.11 rows=4 width=10)
               ->  Hash  (cost=2.30..2.30 rows=4 width=14)
                     ->  Redistribute Motion 2:3  (slice1; segments: 2)  (cost=0.00..2.30 rows=5 width=14)
                           Hash Key: a.c2
                           ->  Seq Scan on scale_factor_part_distr a  (cost=0.00..2.10 rows=5 width=14)
 Optimizer: Postgres query optimizer
(10 rows)

select * from get_motion_snd_recv($$
  select t1.c1, row_number() over (order by t1.c1 desc) from scale_factor_distr t1 join scale_factor_distr t2 using(c2);
$$);
      node_name      | motion_snd | motion_recv 
---------------------+------------+-------------
 Gather Motion       | 3          | 1
 Redistribute Motion | 3          | 3
 Redistribute Motion | 3          | 3
(3 rows)

explain select t1.c1, row_number() over (order by t1.c1 desc) from scale_factor_distr t1 join scale_factor_distr t2 using(c2);
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 WindowAgg  (cost=7.03..7.20 rows=10 width=4)
   Order By: t1.c1
   ->  Gather Motion 3:1  (slice3; segments: 3)  (cost=7.03..7.05 rows=10 width=4)
         Merge Key: t1.c1
         ->  Sort  (cost=7.03..7.05 rows=4 width=4)
               Sort Key: t1.c1
               ->  Hash Join  (cost=3.43..6.86 rows=4 width=4)
                     Hash Cond: (t1.c2 = t2.c2)
                     ->  Redistribute Motion 3:3  (slice1; segments: 3)  (cost=0.00..3.30 rows=4 width=8)
                           Hash Key: t1.c2
                           ->  Seq Scan on scale_factor_distr t1  (cost=0.00..3.10 rows=4 width=8)
                     ->  Hash  (cost=3.30..3.30 rows=4 width=4)
                           ->  Redistribute Motion 3:3  (slice2; segments: 3)  (cost=0.00..3.30 rows=4 width=4)
                                 Hash Key: t2.c2
                                 ->  Seq Scan on scale_factor_distr t2  (cost=0.00..3.10 rows=4 width=4)
 Optimizer: Postgres query optimizer
(16 rows)

-- start_ignore
drop table scale_factor_repl;
drop table scale_factor_distr;
drop table scale_factor_rand_distr;
drop table scale_factor_part_distr;
drop table scale_factor_partitioned;
drop table scale_factor_master_only;
-- end_ignore
