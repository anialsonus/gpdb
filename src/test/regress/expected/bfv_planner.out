--start_ignore
drop table if exists testbadsql;
NOTICE:  table "testbadsql" does not exist, skipping
drop table if exists bfv_planner_x;
NOTICE:  table "bfv_planner_x" does not exist, skipping
drop table if exists bfv_planner_foo;
NOTICE:  table "bfv_planner_foo" does not exist, skipping
--end_ignore
CREATE TABLE testbadsql(id int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'id' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE bfv_planner_x(i integer);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE bfv_planner_foo AS SELECT i as a, i+1 as b from generate_series(1,10)i;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause. Creating a NULL policy entry.
--
-- Test unexpected internal error (execQual.c:4413) when using subquery+window function+union in 4.2.6.x
--
-- Q1
select * from
(SELECT  MIN(id) OVER () minid FROM testbadsql
UNION
SELECT  MIN(id) OVER () minid FROM testbadsql
) tmp
where tmp.minid=123;
 minid 
-------
(0 rows)

-- Q2
select * from
(SELECT  MIN(id) OVER () minid FROM testbadsql
UNION
SELECT 1
) tmp
where tmp.minid=123;
 minid 
-------
(0 rows)

-- Q3
select * from
(SELECT  MIN(id) OVER () minid FROM testbadsql) tmp
where tmp.minid=123;
 minid 
-------
(0 rows)

-- Q4
SELECT * from (
  SELECT max(i) over () as w from bfv_planner_x Union Select 1 as w)
as bfv_planner_foo where w > 0;
 w 
---
 1
(1 row)

--
-- Test query when using median function with count(*)
--
--start_ignore
drop table if exists testmedian;
NOTICE:  table "testmedian" does not exist, skipping
--end_ignore
CREATE TABLE testmedian
(
  a character(2) NOT NULL,
  b character varying(8) NOT NULL,
  c character varying(8) NOT NULL,
  value1 double precision,
  value2 double precision
)
WITH (
  OIDS=FALSE
)
DISTRIBUTED BY (b,c);
insert into testmedian
select i, i, i, i, i
from  (select * from generate_series(1, 99) i ) a ;
-- Test with count()
select median(value1), count(*)
from  testmedian
where c ='55'
group by b, c, value2;
 median | count 
--------+-------
     55 |     1
(1 row)

-- Test with varying ORDER-BY clause
select median(value1), count(*)
from  testmedian
where c ='25'
group by a, b, c, value2
order by c,b;
 median | count 
--------+-------
     25 |     1
(1 row)

-- Test with varying ORDER-BY clause
select median(value1), count(*)
from  testmedian
where c ='55'
group by b,c,value1
order by b, c, value1;
 median | count 
--------+-------
     55 |     1
(1 row)

-- Test with sum()
select median(value1), sum(value2)
from  testmedian
where c ='55'
group by b, c, value2;
 median | sum 
--------+-----
     55 |  55
(1 row)

-- Test with min()
select median(value1), min(c)
from  testmedian
where c ='55'
group by b, c, value2;
 median | min 
--------+-----
     55 | 55
(1 row)

-- Test with varying GROUP-BY clause
select median(value1), count(*)
from  testmedian
where c ='55'
group by b;
 median | count 
--------+-------
     55 |     1
(1 row)

-- Test with varying GROUP-BY clause
select median(value1), count(*)
from  testmedian
where c ='55'
group by b,c;
 median | count 
--------+-------
     55 |     1
(1 row)

-- Test with varying GROUP-BY clause
select median(value1), count(*)
from  testmedian
where c ='55'
group by c,b;
 median | count 
--------+-------
     55 |     1
(1 row)

-- Test with varying GROUP-BY clause
select median(value1), count(*)
from  testmedian
where c ='55'
group by b,c,value1;
 median | count 
--------+-------
     55 |     1
(1 row)

-- Test with varying ORDER-BY clause
select median(value1), count(*)
from  testmedian
where c ='25'
group by b, value1
order by b;
 median | count 
--------+-------
     25 |     1
(1 row)

-- Test with varying ORDER-BY clause
select median(value1), count(*)
from  testmedian
where c ='25'
group by b, c, value2
order by b,c;
 median | count 
--------+-------
     25 |     1
(1 row)

-- Test inheritance planning, when a SubPlan is duplicated for different
-- child tables.
create table r (a int) distributed by (a);
create table p (a int, b int) distributed by (a);
create table p2 (a int, b int) inherits (p) distributed by (b);
NOTICE:  merging column "a" with inherited definition
NOTICE:  merging column "b" with inherited definition
insert into r values (3);
insert into p select a, b from generate_series(1,3) a, generate_series(1,3) b;
delete from p where b = 1 or (b=2 and a in (select r.a from r));
select * from p;
 a | b 
---+---
 3 | 3
 1 | 2
 1 | 3
 2 | 2
 2 | 3
(5 rows)

delete from p where b = 1 or (b=2 and a in (select b from r));
select * from p;
 a | b 
---+---
 1 | 2
 1 | 3
 2 | 3
 3 | 3
(4 rows)

-- Test planning of IS NOT FALSE. We used treat "(a = b) IS NOT FALSE" as
-- hash joinable, and create a plan with a hash join on "(a = b)". That
-- was wrong, because NULLs are treated differently.
create table booltest (b bool);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'b' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into booltest values ('t');
insert into booltest values (null);
select * from booltest a, booltest b where (a.b = b.b) is not false;
 b | b 
---+---
   | 
   | t
 t | 
 t | t
(4 rows)

-- Lossy index qual, used as a partial index predicate, and same column is
-- used in FOR SHARE. Once upon a time, this happened to tickle a bug in the
-- planner at one point.
create table tstest (t tsvector);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, and no column type is suitable for a distribution key. Creating a NULL policy entry.
create index i_tstest on tstest using gist (t) WHERE t @@ 'bar';
insert into tstest values ('foo');
insert into tstest values ('bar');
set enable_bitmapscan =off;
set enable_seqscan =off;
select * from tstest where t @@ 'bar' for share of tstest;
   t   
-------
 'bar'
(1 row)

-- Stable (and volatile) functions need to be re-evaluated on every
-- execution of a prepared statement. There used to be a bug, where
-- they were evaluated once at planning time or at first execution,
-- and the same value was incorrectly reused on subsequent executions.
create function stabletestfunc() returns integer as $$
begin
  raise notice 'stabletestfunc executed';
  return 123;
end;
$$ language plpgsql stable;
create table stabletesttab (id integer);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'id' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into stabletesttab values (1);
insert into stabletesttab values (1000);
-- This might evaluate the function, for cost estimate purposes. That's
-- not of importance for this test.
prepare myprep as select * from stabletesttab where id < stabletestfunc();
NOTICE:  stabletestfunc executed
-- Check that the stable function should be re-executed on every execution of the prepared statetement.
execute myprep;
NOTICE:  stabletestfunc executed
NOTICE:  stabletestfunc executed
 id 
----
  1
(1 row)

execute myprep;
NOTICE:  stabletestfunc executed
NOTICE:  stabletestfunc executed
 id 
----
  1
(1 row)

execute myprep;
NOTICE:  stabletestfunc executed
NOTICE:  stabletestfunc executed
 id 
----
  1
(1 row)

-- Test that pl/pgsql simple expressions are not considered a
-- oneoffPlan.  We validate this by ensuring that a simple expression
-- involving a stable function is planned only once and the same plan
-- is re-executed for each tuple.  The NOTICE in the immutable
-- function allows us to detect when it is executed.  We assume that
-- the planner folds immutablefunc() into a const.
CREATE FUNCTION immutablefunc() RETURNS int2
LANGUAGE plpgsql IMMUTABLE STRICT AS
$$
BEGIN
	raise notice 'immutablefunc executed';
	return 42;
END
$$;
CREATE FUNCTION stablenow (dummy int2) RETURNS timestamp
LANGUAGE plpgsql STABLE STRICT AS
$fn$
BEGIN
	return now();
END
$fn$;
CREATE FUNCTION volatilefunc(a int) RETURNS int
LANGUAGE plpgsql VOLATILE STRICT AS
$fn$
DECLARE
  t timestamp;
BEGIN
	t := stablenow(immutablefunc());
	if date_part('month', t) > a then
		return 0;
	else
		return 1;
	end if;
END
$fn$;
CREATE TABLE oneoffplantest (a int) distributed by (a);
INSERT INTO oneoffplantest VALUES (0), (0), (0);
-- Plan for the following query should be cached such that the call to
-- immutablefun() is folded into a const.  Note that all the
-- statements within volatilefunc() are pl/pgsql simple expressions.
-- Their plans should NOT be classified as oneoffPlan and should be
-- cached.  So we expect the NOTICE to be printed only once,
-- regardless of the number of tuples in the table.
select volatilefunc(a) from oneoffplantest;
NOTICE:  immutablefunc executed  (seg0 slice1 127.0.1.1:25432 pid=6257)
CONTEXT:  SQL statement "SELECT stablenow(immutablefunc())"
PL/pgSQL function "volatilefunc" line 4 at assignment
 volatilefunc 
--------------
            0
            0
            0
(3 rows)

-- Test cases around using volatile function in replicated datasets that
-- eventually violates replicating property and requires from plan to process
-- rows in a single node.
-- Preparing stage
create table t_hashdist as select i as a, i as b, i as c from generate_series(1, 10) as i distributed by (a);
create function values_wrapper() returns setof int
immutable rows 1000 language plpgsql
as $$
begin
    return query select (values (0)) as t;
end;
$$;
set optimizer to off;
-- gp_execution_segment() function have to be issued on one node (segment or coordinator) under Result node.
-- The result should be 1.
select count(distinct(j)) from (select gp_execution_segment()) as t(j), t_hashdist;
 count 
-------
     1
(1 row)

-- values_wrapper() / values expression with volatile predicate have to be issued on one node
explain select * from (select a from values_wrapper() a) x, t_hashdist where x.a > random();
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Nested Loop  (cost=3.31..337.48 rows=3334 width=16)
   ->  Function Scan on values_wrapper a  (cost=0.00..267.50 rows=334 width=4)
         Filter: a::double precision > random()
   ->  Materialize  (cost=3.31..3.41 rows=4 width=12)
         ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..3.30 rows=10 width=12)
               ->  Seq Scan on t_hashdist  (cost=0.00..3.10 rows=4 width=12)
 Settings:  enable_bitmapscan=off; enable_seqscan=off; optimizer=off
 Optimizer status: legacy query optimizer
(8 rows)

explain select * from (select a from (values (0)) t(a)) x, t_hashdist where x.a > random();
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)  (cost=0.06..3.76 rows=10 width=16)
   ->  Nested Loop  (cost=0.06..3.76 rows=4 width=16)
         ->  Seq Scan on t_hashdist  (cost=0.00..3.10 rows=4 width=12)
         ->  Materialize  (cost=0.06..0.09 rows=1 width=4)
               ->  Broadcast Motion 1:3  (slice1; segments: 1)  (cost=0.00..0.06 rows=3 width=4)
                     ->  Values Scan on "*VALUES*"  (cost=0.00..0.02 rows=1 width=4)
                           Filter: column1::double precision > random()
 Settings:  enable_bitmapscan=off; enable_seqscan=off; optimizer=off
 Optimizer status: legacy query optimizer
(9 rows)

-- join values_wrapper() on values_wrapper() with volatile join condition have to be issued on one node
explain select * from t_hashdist,
    (select a from values_wrapper() a) x,
    (select a from values_wrapper() a) y
    where x.a + y.a > random();
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Nested Loop  (cost=264.31..97190.98 rows=3333334 width=20)
   ->  Nested Loop  (cost=261.00..30521.00 rows=333334 width=8)
         Join Filter: (a.a + a.a)::double precision > random()
         ->  Function Scan on values_wrapper a  (cost=0.00..260.00 rows=334 width=4)
         ->  Materialize  (cost=261.00..271.00 rows=334 width=4)
               ->  Function Scan on values_wrapper a  (cost=0.00..260.00 rows=334 width=4)
   ->  Materialize  (cost=3.31..3.41 rows=4 width=12)
         ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..3.30 rows=10 width=12)
               ->  Seq Scan on t_hashdist  (cost=0.00..3.10 rows=4 width=12)
 Settings:  enable_bitmapscan=off; enable_seqscan=off; optimizer=off
 Optimizer status: legacy query optimizer
(11 rows)

-- subquery have to be issued on one node
explain select * from t_hashdist where a > All (select random() from values_wrapper());
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Nested Loop Left Anti Semi Join (Not-In)  (cost=273.50..526.80 rows=10 width=12)
   Join Filter: t_hashdist.a::double precision <= "NotIn_SUBQUERY".random
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..3.30 rows=10 width=12)
         ->  Seq Scan on t_hashdist  (cost=0.00..3.10 rows=4 width=12)
   ->  Materialize  (cost=273.50..283.50 rows=334 width=8)
         ->  Subquery Scan "NotIn_SUBQUERY"  (cost=0.00..272.50 rows=1000 width=8)
               ->  Function Scan on values_wrapper  (cost=0.00..262.50 rows=1000 width=0)
 Settings:  enable_bitmapscan=off; enable_seqscan=off; optimizer=off
 Optimizer status: legacy query optimizer
(9 rows)

explain select * from t_hashdist where a > All (select random() from (values (0)) as t);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)  (cost=0.07..3.92 rows=4 width=12)
   ->  Nested Loop Left Anti Semi Join (Not-In)  (cost=0.07..3.92 rows=2 width=12)
         Join Filter: t_hashdist.a::double precision <= "NotIn_SUBQUERY".random
         ->  Seq Scan on t_hashdist  (cost=0.00..3.10 rows=4 width=12)
         ->  Materialize  (cost=0.07..0.10 rows=1 width=8)
               ->  Broadcast Motion 1:3  (slice1; segments: 1)  (cost=0.00..0.07 rows=3 width=8)
                     ->  Subquery Scan "NotIn_SUBQUERY"  (cost=0.00..0.03 rows=1 width=8)
                           ->  Values Scan on "*VALUES*"  (cost=0.00..0.02 rows=1 width=0)
 Settings:  enable_bitmapscan=off; enable_seqscan=off; optimizer=off
 Optimizer status: legacy query optimizer
(10 rows)

-- values_wrapper() / values expression have to be issued on one node and broadcastly pulled up into semi join
explain select * from t_hashdist where a in (select random()::int from values_wrapper());
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)  (cost=300.88..300.98 rows=10 width=18)
   ->  HashAggregate  (cost=300.88..300.98 rows=4 width=18)
         Group By: t_hashdist.ctid::bigint
         ->  Hash Join  (cost=3.23..300.85 rows=4 width=18)
               Hash Cond: (random()::integer) = t_hashdist.a
               ->  Redistribute Motion 1:3  (slice1; segments: 1)  (cost=0.00..295.00 rows=1000 width=4)
                     Hash Key: (random()::integer)
                     ->  Function Scan on values_wrapper  (cost=0.00..265.00 rows=1000 width=0)
               ->  Hash  (cost=3.10..3.10 rows=4 width=18)
                     ->  Seq Scan on t_hashdist  (cost=0.00..3.10 rows=4 width=18)
 Settings:  enable_bitmapscan=off; enable_seqscan=off; optimizer=off
 Optimizer status: legacy query optimizer
(12 rows)

explain select * from t_hashdist where a in (select random()::int from (values (0)) as t);
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)  (cost=0.06..3.22 rows=4 width=12)
   ->  Hash EXISTS Join  (cost=0.06..3.22 rows=2 width=12)
         Hash Cond: t_hashdist.a = (random()::integer)
         ->  Seq Scan on t_hashdist  (cost=0.00..3.10 rows=4 width=12)
         ->  Hash  (cost=0.05..0.05 rows=1 width=4)
               ->  Redistribute Motion 1:3  (slice1; segments: 1)  (cost=0.00..0.05 rows=1 width=4)
                     Hash Key: (random()::integer)
                     ->  Values Scan on "*VALUES*"  (cost=0.00..0.02 rows=1 width=0)
 Settings:  enable_bitmapscan=off; enable_seqscan=off; optimizer=off
 Optimizer status: legacy query optimizer
(10 rows)

-- different combinations of using volatile function in target list, group by and having clauses
explain select * from t_hashdist cross join (select random() from values_wrapper()) x;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Nested Loop  (cost=3.31..475.81 rows=10000 width=20)
   ->  Function Scan on values_wrapper  (cost=0.00..262.50 rows=1000 width=0)
   ->  Materialize  (cost=3.31..3.41 rows=4 width=12)
         ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..3.30 rows=10 width=12)
               ->  Seq Scan on t_hashdist  (cost=0.00..3.10 rows=4 width=12)
 Settings:  enable_bitmapscan=off; enable_seqscan=off; optimizer=off
 Optimizer status: legacy query optimizer
(7 rows)

explain select * from t_hashdist cross join (select random() from (values (0)) as t) x;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)  (cost=0.07..3.77 rows=10 width=20)
   ->  Nested Loop  (cost=0.07..3.77 rows=4 width=20)
         ->  Seq Scan on t_hashdist  (cost=0.00..3.10 rows=4 width=12)
         ->  Materialize  (cost=0.07..0.10 rows=1 width=8)
               ->  Broadcast Motion 1:3  (slice1; segments: 1)  (cost=0.00..0.07 rows=3 width=8)
                     ->  Values Scan on "*VALUES*"  (cost=0.00..0.02 rows=1 width=0)
 Settings:  enable_bitmapscan=off; enable_seqscan=off; optimizer=off
 Optimizer status: legacy query optimizer
(8 rows)

explain select * from t_hashdist cross join (select a, sum(random()) from values_wrapper() a group by a) x;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Nested Loop  (cost=268.31..493.31 rows=10000 width=24)
   ->  HashAggregate  (cost=265.00..280.00 rows=1000 width=12)
         Group By: a.a
         ->  Function Scan on values_wrapper a  (cost=0.00..260.00 rows=334 width=4)
   ->  Materialize  (cost=3.31..3.41 rows=4 width=12)
         ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..3.30 rows=10 width=12)
               ->  Seq Scan on t_hashdist  (cost=0.00..3.10 rows=4 width=12)
 Settings:  enable_bitmapscan=off; enable_seqscan=off; optimizer=off
 Optimizer status: legacy query optimizer
(9 rows)

explain select * from t_hashdist cross join (select a, sum(random()) from (values (0)) as t(a) group by a) x;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)  (cost=0.09..3.79 rows=10 width=24)
   ->  Nested Loop  (cost=0.09..3.79 rows=4 width=24)
         ->  Seq Scan on t_hashdist  (cost=0.00..3.10 rows=4 width=12)
         ->  Materialize  (cost=0.09..0.12 rows=1 width=12)
               ->  Broadcast Motion 1:3  (slice1; segments: 1)  (cost=0.02..0.08 rows=3 width=12)
                     ->  HashAggregate  (cost=0.02..0.03 rows=1 width=12)
                           Group By: "*VALUES*".column1
                           ->  Values Scan on "*VALUES*"  (cost=0.00..0.01 rows=1 width=4)
 Settings:  enable_bitmapscan=off; enable_seqscan=off; optimizer=off
 Optimizer status: legacy query optimizer
(10 rows)

explain select * from t_hashdist cross join (
    select random() as k, sum(a) from values_wrapper() a group by k
) x;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Nested Loop  (cost=270.81..495.81 rows=10000 width=28)
   ->  HashAggregate  (cost=267.50..282.50 rows=1000 width=16)
         Group By: random()
         ->  Function Scan on values_wrapper a  (cost=0.00..262.50 rows=334 width=4)
   ->  Materialize  (cost=3.31..3.41 rows=4 width=12)
         ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..3.30 rows=10 width=12)
               ->  Seq Scan on t_hashdist  (cost=0.00..3.10 rows=4 width=12)
 Settings:  enable_bitmapscan=off; enable_seqscan=off; optimizer=off
 Optimizer status: legacy query optimizer
(9 rows)

explain select * from t_hashdist cross join (
    select random() as k, sum(a) from (values (0)) as t(a) group by k
) x;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)  (cost=0.09..3.79 rows=10 width=28)
   ->  Nested Loop  (cost=0.09..3.79 rows=4 width=28)
         ->  Seq Scan on t_hashdist  (cost=0.00..3.10 rows=4 width=12)
         ->  Materialize  (cost=0.09..0.12 rows=1 width=16)
               ->  Broadcast Motion 1:3  (slice1; segments: 1)  (cost=0.02..0.09 rows=3 width=16)
                     ->  HashAggregate  (cost=0.02..0.04 rows=1 width=16)
                           Group By: random()
                           ->  Values Scan on "*VALUES*"  (cost=0.00..0.02 rows=1 width=4)
 Settings:  enable_bitmapscan=off; enable_seqscan=off; optimizer=off
 Optimizer status: legacy query optimizer
(10 rows)

explain select * from t_hashdist cross join (
    select a, count(1) as s from values_wrapper() a group by a having count(1) > random() order by a
) x;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Nested Loop  (cost=313.14..555.64 rows=10000 width=24)
   ->  GroupAggregate  (cost=309.83..342.33 rows=1000 width=12)
         Filter: count(1)::double precision > random()
         Group By: a.a
         ->  Sort  (cost=309.83..312.33 rows=334 width=4)
               Sort Key: a.a
               ->  Function Scan on values_wrapper a  (cost=0.00..260.00 rows=334 width=4)
   ->  Materialize  (cost=3.31..3.41 rows=4 width=12)
         ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..3.30 rows=10 width=12)
               ->  Seq Scan on t_hashdist  (cost=0.00..3.10 rows=4 width=12)
 Settings:  enable_bitmapscan=off; enable_seqscan=off; optimizer=off
 Optimizer status: legacy query optimizer
(12 rows)

explain select * from t_hashdist cross join (
    select a, count(1) as s from (values (0)) as t(a) group by a having count(1) > random() order by a
) x;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)  (cost=0.11..3.81 rows=10 width=24)
   ->  Nested Loop  (cost=0.11..3.81 rows=4 width=24)
         ->  Seq Scan on t_hashdist  (cost=0.00..3.10 rows=4 width=12)
         ->  Materialize  (cost=0.11..0.14 rows=1 width=12)
               ->  Broadcast Motion 1:3  (slice1; segments: 1)  (cost=0.02..0.11 rows=3 width=12)
                     ->  GroupAggregate  (cost=0.02..0.06 rows=1 width=12)
                           Filter: count(1)::double precision > random()
                           Group By: "*VALUES*".column1
                           ->  Sort  (cost=0.02..0.03 rows=1 width=4)
                                 Sort Key: "*VALUES*".column1
                                 ->  Values Scan on "*VALUES*"  (cost=0.00..0.01 rows=1 width=4)
 Settings:  enable_bitmapscan=off; enable_seqscan=off; optimizer=off
 Optimizer status: legacy query optimizer
(13 rows)

-- limit clause transforms replicated dataset to singleton
explain select * from t_hashdist cross join (select * from values_wrapper() limit 1) x;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)  (cost=0.31..4.01 rows=10 width=16)
   ->  Nested Loop  (cost=0.31..4.01 rows=4 width=16)
         ->  Seq Scan on t_hashdist  (cost=0.00..3.10 rows=4 width=12)
         ->  Materialize  (cost=0.31..0.34 rows=1 width=4)
               ->  Broadcast Motion 1:3  (slice1; segments: 1)  (cost=0.00..0.31 rows=3 width=4)
                     ->  Limit  (cost=0.00..0.26 rows=1 width=4)
                           ->  Function Scan on values_wrapper  (cost=0.00..260.00 rows=334 width=4)
 Settings:  enable_bitmapscan=off; enable_seqscan=off; optimizer=off
 Optimizer status: legacy query optimizer
(9 rows)

explain select * from t_hashdist cross join (select * from (values (0)) as t limit 1) x;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)  (cost=0.07..3.77 rows=10 width=16)
   ->  Nested Loop  (cost=0.07..3.77 rows=4 width=16)
         ->  Seq Scan on t_hashdist  (cost=0.00..3.10 rows=4 width=12)
         ->  Materialize  (cost=0.07..0.10 rows=1 width=4)
               ->  Broadcast Motion 1:3  (slice1; segments: 1)  (cost=0.00..0.06 rows=3 width=4)
                     ->  Limit  (cost=0.00..0.01 rows=1 width=4)
                           ->  Values Scan on "*VALUES*"  (cost=0.00..0.01 rows=1 width=4)
 Settings:  enable_bitmapscan=off; enable_seqscan=off; optimizer=off
 Optimizer status: legacy query optimizer
(9 rows)

drop function values_wrapper();
-- start_ignore
drop table if exists bfv_planner_x;
drop table if exists testbadsql;
drop table if exists bfv_planner_foo;
drop table if exists testmedian;
-- end_ignore
